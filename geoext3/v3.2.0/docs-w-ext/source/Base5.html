<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-sparkline-Base'>/**
</span> * @class Ext.sparkline.Base
 *
 * The base class for ExtJS SparkLines. SparkLines are small, inline graphs used to visually
 * display small amounts of data. For large datasets, use the {@link Ext.chart.AbstractChart chart package}.
 *
 * The SparkLine subclasses accept an {@link #values array of values}, and present the data in different visualizations.
 *
 *     @example
 *     new Ext.Panel({
 *         height: 300,
 *         width: 600,
 *         frame: true,
 *         title: 'Test Sparklines',
 *         renderTo:document.body,
 *         bodyPadding: 10,
 *
 *         // Named listeners will resolve to methods in this Panel
 *         defaultListenerScope: true,
 *
 *         // Named references will be collected, and can be access from this Panel
 *         referenceHolder: true,
 *
 *         items: [{
 *             reference: 'values',
 *             xtype: 'textfield',
 *             fieldLabel: 'Values',
 *             validator: function(v) {
 *                 var result = [];
 *
 *                 v = v.replace(/\s/g, '');
 *                 v = v.replace(/,$/, '');
 *                 v = v.split(',');
 *                 for (var i = 0; i &lt; v.length; i++) {
 *                     if (!Ext.isNumeric(v[i])) {
 *                         return 'Value must be a comma separated array of numbers';
 *                     }
 *                     result.push(parseInt(v[i], 10));
 *                 }
 *                 this.values = result;
 *                 return true;
 *             },
 *             listeners: {
 *                 change: 'onTypeChange',
 *                 buffer: 500,
 *                 afterrender: {
 *                     fn: 'afterTypeRender',
 *                     single: true
 *                 }
 *             }
 *         }, {
 *             reference: 'type',
 *             xtype: 'combobox',
 *             fieldLabel: 'Type',
 *             store: [
 *                 ['sparklineline',     'Line'],
 *                 ['sparklinebox',      'Box'],
 *                 ['sparklinebullet',   'Bullet'],
 *                 ['sparklinediscrete', 'Discrete'],
 *                 ['sparklinepie',      'Pie'],
 *                 ['sparklinetristate', 'TriState']
 *             ],
 *             value: 'sparklineline',
 *             listeners: {
 *                 change: 'onTypeChange',
 *                 buffer: 500
 *             }
 *         }],
 *
 *         // Start with a line plot. 
 *         afterTypeRender: function(typeField) {
 *             typeField.setValue('6,10,4,-3,7,2');
 *         },
 *
 *         onTypeChange: function() {
 *             var me = this,
 *                 refs = me.getReferences(),
 *                 config;
 *
 *             if (me.sparkLine) {
 *                 me.remove(me.sparkLine, true);
 *             }
 *             config = {
 *                 xtype: refs.type.getValue(),
 *                 values: refs.values.values,
 *                 height: 25,
 *                 width: 100                    
 *             };
 *	           me.sparkLine = Ext.create(config);
 *             me.add(me.sparkLine);
 *
 *             // Put under fields
 *             me.sparkLine.el.dom.style.marginLeft = refs.type.labelEl.getWidth() + 'px';
 *         }
 *     });
 *
 */
Ext.define('Ext.sparkline.Base', {
    extend: 'Ext.Gadget',
    xtype: 'sparkline',
    requires: [
        'Ext.XTemplate',
        'Ext.sparkline.CanvasCanvas',
        'Ext.sparkline.VmlCanvas',
        'Ext.util.Color'
    ],

    cachedConfig: {
<span id='Ext-sparkline-Base-cfg-baseCls'>        baseCls: Ext.baseCSSPrefix + 'sparkline',
</span>
<span id='Ext-sparkline-Base-cfg-lineColor'>        /**
</span>         * @cfg {String} [lineColor=#157fcc] The hex value for line colors in graphs which display lines ({@link Ext.sparkline.Box Box}, {@link Ext.sparkline.Discrete Discrete and {@link Ext.sparkline.Line Line}).
         */
        lineColor: '#157fcc',

<span id='Ext-sparkline-Base-cfg-defaultPixelsPerValue'>        defaultPixelsPerValue: 3,
</span>
<span id='Ext-sparkline-Base-cfg-tagValuesAttribute'>        tagValuesAttribute: 'values',
</span>
<span id='Ext-sparkline-Base-cfg-enableTagOptions'>        enableTagOptions: false,
</span>        
<span id='Ext-sparkline-Base-cfg-enableHighlight'>        enableHighlight: true,
</span>        
<span id='Ext-sparkline-Base-cfg-highlightColor'>        /**
</span>         * @cfg {String} [highlightColor=null] The hex value for the highlight color to use when mouseing over a graph segment.
         */
        highlightColor: null,
        
<span id='Ext-sparkline-Base-cfg-highlightLighten'>        /**
</span>         * @cfg {Number} [highlightLighten] How much to lighten the highlight color by when mouseing over a graph segment.
         */
        highlightLighten: 0.1,
        
<span id='Ext-sparkline-Base-cfg-tooltipSkipNull'>        /**
</span>         * @cfg {Boolean} [tooltipSkipNull=true] Null values will not have a tooltip displayed.
         */
        tooltipSkipNull: true,
        
<span id='Ext-sparkline-Base-cfg-tooltipPrefix'>        /**
</span>         * @cfg {String} [tooltipPrefix] A string to prepend to each field displayed in a tooltip.
         */
        tooltipPrefix: '',
        
<span id='Ext-sparkline-Base-cfg-tooltipSuffix'>        /**
</span>         * @cfg {String} [tooltipSuffix] A string to append to each field displayed in a tooltip.
         */
        tooltipSuffix: '',
        
<span id='Ext-sparkline-Base-cfg-disableTooltips'>        /**
</span>         * @cfg {Boolean} [disableTooltips=false] Set to `true` to disable mouseover tooltips.
         */
        disableTooltips: false,
        
<span id='Ext-sparkline-Base-cfg-disableInteraction'>        disableInteraction: false,
</span>        
<span id='Ext-sparkline-Base-cfg-tipTpl'>        /**
</span>         * @cfg {String/Ext.XTemplate} [tipTpl] An XTemplate used to display the value or values in a tooltip when hovering over a Sparkline.
         *
         * The implemented subclases all define their own `tipTpl`, but it can be overridden.
         */
        tipTpl: null
    },

    config: {
<span id='Ext-sparkline-Base-cfg-values'>        /**
</span>         * @cfg {Number[]} values An array of numbers which define the chart.
         */
        values: null
    },

<span id='Ext-sparkline-Base-property-element'>    element: {
</span>        tag: 'canvas',
        reference: 'element',
        style: {
            display: 'inline-block',
            verticalAlign: 'top'
        },
        listeners: {
            mouseenter: 'onMouseEnter',
            mouseleave: 'onMouseLeave',
            mousemove: 'onMouseMove'
        },
        // Create canvas zero sized so that it does not affect the containing element's initial layout
        // https://sencha.jira.com/browse/EXTJSIV-10145
        width: 0,
        height: 0
    },
    
<span id='Ext-sparkline-Base-property-defaultBindProperty'>    defaultBindProperty: 'values',
</span>
<span id='Ext-sparkline-Base-property-redrawQueue'>    // When any config is changed, the canvas needs to be redrawn.
</span>    // This is done at the next animation frame when this queue is traversed.
    redrawQueue: {},

    inheritableStatics: {
<span id='Ext-sparkline-Base-static-property-sparkLineTipClass'>        /**
</span>         * @private
         * @static
         * @inheritable
         */
        sparkLineTipClass: Ext.baseCSSPrefix + 'sparkline-tip-target',

<span id='Ext-sparkline-Base-static-method-onClassCreated'>        /**
</span>         * @private
         * @static
         * @inheritable
         */
        onClassCreated: function(cls) {
            var configApplier = cls.prototype.applyConfigChange,
                proto = cls.prototype,
                configs = cls.getConfigurator().configs,
                config,
                applierName;

            // Set up an applier for all local configs which kicks off a request to redraw on the next animation frame
            for (config in configs) {
                // tipTpl not included in this scheme
                if (config !== 'tipTpl') {
                    applierName = Ext.Config.get(config).names.apply;
                    if (proto[applierName]) {
                        proto[applierName] = Ext.Function.createSequence(proto[applierName], configApplier);
                    } else {
                        proto[applierName] = configApplier;
                    }
                }
            }    
        }
    },

<span id='Ext-sparkline-Base-method-constructor'>    constructor: function(config) {
</span>        var me = this;

        // The canvas sets our element config
        me.canvas = Ext.supports.Canvas ? new Ext.sparkline.CanvasCanvas(me)
                                        : new Ext.sparkline.VmlCanvas(me);
        if (!me.getDisableTooltips()) {
            me.element.cls = Ext.sparkline.Base.sparkLineTipClass;
        }

        Ext.apply(me, config);
        me.callParent([config]);
    },

<span id='Ext-sparkline-Base-method-all'>    // determine if all values of an array match a value
</span>    // returns true if the array is empty
    all: function (val, arr, ignoreNull) {
        var i;
        for (i = arr.length; i--; ) {
            if (ignoreNull &amp;&amp; arr[i] === null) {
                continue;
            }
            if (arr[i] !== val) {
                return false;
            }
        }
        return true;
    },

<span id='Ext-sparkline-Base-method-applyConfigChange'>    // generic config value applier.
</span>    // Adds this to the queue to do a redraw on the next animation frame
    applyConfigChange: function(newValue) {
        var me = this;
        me.redrawQueue[me.getId()] = me;

        // Ensure that there is a single timer to handle all queued redraws.
        if (!me.redrawTimer) {
            Ext.sparkline.Base.prototype.redrawTimer =
                    Ext.Function.requestAnimationFrame(me.processRedrawQueue);
        }
        return newValue;
    },

<span id='Ext-sparkline-Base-method-applyTipTpl'>    // Appliers convert an incoming config value.
</span>    // Ensure the tipTpl is an XTemplate
    applyTipTpl: function(tipTpl) {
        if (tipTpl &amp;&amp; !tipTpl.isTemplate) {
            tipTpl = new Ext.XTemplate(tipTpl);
        }
        return tipTpl;
    },

<span id='Ext-sparkline-Base-method-normalizeValue'>    normalizeValue: function (val) {
</span>        var nf;
        switch (val) {
            case 'undefined':
                val = undefined;
                break;
            case 'null':
                val = null;
                break;
            case 'true':
                val = true;
                break;
            case 'false':
                val = false;
                break;
            default:
                nf = parseFloat(val);
                if (val == nf) {
                    val = nf;
                }
        }
        return val;
    },

<span id='Ext-sparkline-Base-method-normalizeValues'>    normalizeValues: function (vals) {
</span>        var i, result = [];
        for (i = vals.length; i--;) {
            result[i] = this.normalizeValue(vals[i]);
        }
        return result;
    },

<span id='Ext-sparkline-Base-method-updateWidth'>    updateWidth: function(width, oldWidth) {
</span>        var me = this,
            dom = me.element.dom,
            measurer = me.measurer;

        me.callParent([width, oldWidth]);
        me.canvas.setWidth(width);
        me.width = width;
        if (me.height == null &amp;&amp; measurer) {
            me.setHeight(parseInt(measurer.getCachedStyle(dom.parentNode, 'line-height'), 10));
        }
    },

<span id='Ext-sparkline-Base-method-updateHeight'>    updateHeight: function(height, oldHeight) {
</span>        var me = this;

        me.callParent([height, oldHeight]);
        me.canvas.setHeight(height);
        me.height = height;
    },

<span id='Ext-sparkline-Base-method-applyValues'>    applyValues: function(values, oldValues)  {
</span>        if (values &amp;&amp; oldValues &amp;&amp; Ext.Array.equals(values, oldValues)) {
            values = undefined;
        }
        return values;
    },

<span id='Ext-sparkline-Base-method-updateValues'>    updateValues: function(values) {
</span>        this.values = values;
    },

<span id='Ext-sparkline-Base-method-redraw'>    redraw: function() {
</span>        var me = this;

        if (!me.destroyed &amp;&amp; me.getValues()) {
            me.onUpdate();
            me.canvas.onOwnerUpdate();
            me.renderGraph();
        }
    },

<span id='Ext-sparkline-Base-method-onUpdate'>    onUpdate: Ext.emptyFn,
</span>
<span id='Ext-sparkline-Base-method-renderGraph'>    /*
</span>     * Render the chart to the canvas
     */
    renderGraph: function () {
        var ret = true;
        if (this.disabled) {
            this.canvas.reset();
            ret = false;
        }
        return ret;
    },

<span id='Ext-sparkline-Base-method-onMouseEnter'>    onMouseEnter: function(e) {
</span>        this.onMouseMove(e);
    },

<span id='Ext-sparkline-Base-method-onMouseMove'>    onMouseMove: function (e) {
</span>        this.currentPageXY = e.getPoint();
        this.redraw();
    },

<span id='Ext-sparkline-Base-method-onMouseLeave'>    onMouseLeave: function () {
</span>        var me = this;
        me.currentPageXY = me.targetX = me.targetY = null;
        me.redraw();
        me.hideTip();
    },

<span id='Ext-sparkline-Base-method-updateDisplay'>    updateDisplay: function () {
</span>        var me = this,
            values = me.getValues(),
            offset, tipHtml, region;

        if (values &amp;&amp; values.length &amp;&amp; me.currentPageXY &amp;&amp; me.el.getRegion().contains(me.currentPageXY)) {
            offset = me.canvas.el.getXY();
            region = me.getRegion(me.currentPageXY[0] - offset[0], me.currentPageXY[1] - offset[1]);

            if (region != null &amp;&amp; me.isValidRegion(region, values)) {
                if (!me.disableHighlight) {
                    me.renderHighlight(region);
                }
                tipHtml = me.getRegionTooltip(region);
            }
            me.fireEvent('sparklineregionchange', me);

            if (tipHtml) {
                me.tooltip.setHtml(tipHtml);
                me.showTip();
            }
        }

        // No tip content; ensure it's hidden
        if (!tipHtml) {
            me.hideTip();
        }
    },

<span id='Ext-sparkline-Base-method-getRegion'>    /**
</span>     * @method
     * Return a region id for a given x/y co-ordinate
     */
    getRegion: Ext.emptyFn,

<span id='Ext-sparkline-Base-method-getRegionTooltip'>    /**
</span>     * Fetch the HTML to display as a tooltip
     */
    getRegionTooltip: function(region) {
        var me = this,
            entries = [],
            tipTpl = me.getTipTpl(),
            fields, showFields, showFieldsKey, newFields, fv,
            formatter, fieldlen, i, j;

        fields = me.getRegionFields(region);
        formatter = me.tooltipFormatter;
        if (formatter) {
            return formatter(me, me, fields);
        }

        if (!tipTpl) {
            return '';
        }
        if (!Ext.isArray(fields)) {
            fields = [fields];
        }
        showFields = me.tooltipFormatFieldlist;
        showFieldsKey = me.tooltipFormatFieldlistKey;
        if (showFields &amp;&amp; showFieldsKey) {
            // user-selected ordering of fields
            newFields = [];
            for (i = fields.length; i--;) {
                fv = fields[i][showFieldsKey];
                if ((j = Ext.Array.indexOf(fv, showFields)) !== -1) {
                    newFields[j] = fields[i];
                }
            }
            fields = newFields;
        }
        fieldlen = fields.length;

        for (j = 0; j &lt; fieldlen; j++) {
            if (!fields[j].isNull || !me.getTooltipSkipNull()) {
                Ext.apply(fields[j], {
                    prefix: me.getTooltipPrefix(),
                    suffix: me.getTooltipSuffix()
                });
                entries.push(tipTpl.apply(fields[j]));
            }
        }

        if (entries.length) {
            return entries.join('&lt;br&gt;');
        }
        return '';
    },

<span id='Ext-sparkline-Base-method-getRegionFields'>    getRegionFields: Ext.emptyFn,
</span>
<span id='Ext-sparkline-Base-method-calcHighlightColor'>    calcHighlightColor: function(color) {
</span>        var me = this,
            highlightColor = me.getHighlightColor(),
            lighten = me.getHighlightLighten(),
            o;

        if (highlightColor) {
            return highlightColor;
        }
        if (lighten) {
            o = Ext.util.Color.fromString(color);
            if (o) {
                o.lighten(lighten);
                color = o.toHex();
            }
        }
        return color;
    },

<span id='Ext-sparkline-Base-method-destroy'>    destroy: function() {
</span>        delete this.redrawQueue[this.getId()];
        this.callParent();
    },

<span id='Ext-sparkline-Base-property-privates'>    privates: {
</span>        hideTip: Ext.privateFn,

        isValidRegion: function(region, values) {
            return region &lt; values.length;
        },

        showTip: Ext.privateFn
    }
}, function(SparklineBase) {
    var proto = SparklineBase.prototype;

    Ext.onInternalReady(function() {
        proto.tooltip = SparklineBase.constructTip();
    });

    SparklineBase.onClassCreated(SparklineBase);
    
    proto.processRedrawQueue = function () {
        var redrawQueue = proto.redrawQueue,
            id;

        for (id in redrawQueue) {
            redrawQueue[id].redraw();
        }
        proto.redrawQueue = {};
        proto.redrawTimer = 0;
    };

    // If we are on a VML platform (IE8 - TODO: remove this when that retires)...
    if (!Ext.supports.Canvas) {
        SparklineBase.prototype.element = {
            tag: 'span',
            reference: 'element',
            listeners: {
                mouseenter: 'onMouseEnter',
                mouseleave: 'onMouseLeave',
                mousemove: 'onMouseMove'
            },
            style: {
                display: 'inline-block',
                position: 'relative',
                overflow: 'hidden',
                margin: '0px',
                padding: '0px',
                verticalAlign: 'top',
                cursor: 'default'
            },
            children: [{
                tag: 'svml:group',
                reference: 'groupEl',
                coordorigin: '0 0',
                coordsize: '0 0',
                style: 'position:absolute;width:0;height:0;pointer-events:none'
            }]
        };
    }
});
</pre>
</body>
</html>
