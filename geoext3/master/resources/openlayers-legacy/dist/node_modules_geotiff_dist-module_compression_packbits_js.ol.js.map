{"version":3,"file":"node_modules_geotiff_dist-module_compression_packbits_js.ol.js","mappings":"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","sources":["webpack://ol/./node_modules/geotiff/dist-module/compression/basedecoder.js","webpack://ol/./node_modules/geotiff/dist-module/compression/packbits.js","webpack://ol/./node_modules/geotiff/dist-module/predictor.js"],"sourcesContent":["import { applyPredictor } from '../predictor.js';\n\nexport default class BaseDecoder {\n  async decode(fileDirectory, buffer) {\n    const decoded = await this.decodeBlock(buffer);\n    const predictor = fileDirectory.Predictor || 1;\n    if (predictor !== 1) {\n      const isTiled = !fileDirectory.StripOffsets;\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\n      );\n      return applyPredictor(\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\n        fileDirectory.PlanarConfiguration,\n      );\n    }\n    return decoded;\n  }\n}\n","import BaseDecoder from './basedecoder.js';\n\nexport default class PackbitsDecoder extends BaseDecoder {\n  decodeBlock(buffer) {\n    const dataView = new DataView(buffer);\n    const out = [];\n\n    for (let i = 0; i < buffer.byteLength; ++i) {\n      let header = dataView.getInt8(i);\n      if (header < 0) {\n        const next = dataView.getUint8(i + 1);\n        header = -header;\n        for (let j = 0; j <= header; ++j) {\n          out.push(next);\n        }\n        i += 1;\n      } else {\n        for (let j = 0; j <= header; ++j) {\n          out.push(dataView.getUint8(i + j + 1));\n        }\n        i += header + 1;\n      }\n    }\n    return new Uint8Array(out).buffer;\n  }\n}\n","function decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nexport function applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n"],"names":["applyPredictor","BaseDecoder","decode","fileDirectory","buffer","decoded","decodeBlock","predictor","Predictor","isTiled","StripOffsets","tileWidth","TileWidth","ImageWidth","tileHeight","TileLength","RowsPerStrip","ImageLength","BitsPerSample","PlanarConfiguration","PackbitsDecoder","dataView","DataView","out","i","byteLength","header","getInt8","next","getUint8","j","push","Uint8Array","decodeRowAcc","row","stride","length","offset","decodeRowFloatingPoint","bytesPerSample","index","count","wc","copy","slice","b","block","width","height","bitsPerSample","planarConfiguration","Error","Uint16Array","Uint32Array"],"sourceRoot":""}