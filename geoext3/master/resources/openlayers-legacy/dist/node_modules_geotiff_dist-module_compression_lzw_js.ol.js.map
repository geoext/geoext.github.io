{"version":3,"file":"node_modules_geotiff_dist-module_compression_lzw_js.ol.js","mappings":"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","sources":["webpack://ol/./node_modules/geotiff/dist-module/compression/basedecoder.js","webpack://ol/./node_modules/geotiff/dist-module/compression/lzw.js","webpack://ol/./node_modules/geotiff/dist-module/predictor.js"],"sourcesContent":["import { applyPredictor } from '../predictor.js';\n\nexport default class BaseDecoder {\n  async decode(fileDirectory, buffer) {\n    const decoded = await this.decodeBlock(buffer);\n    const predictor = fileDirectory.Predictor || 1;\n    if (predictor !== 1) {\n      const isTiled = !fileDirectory.StripOffsets;\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\n      );\n      return applyPredictor(\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\n        fileDirectory.PlanarConfiguration,\n      );\n    }\n    return decoded;\n  }\n}\n","import BaseDecoder from './basedecoder.js';\n\nconst MIN_BITS = 9;\nconst CLEAR_CODE = 256; // clear code\nconst EOI_CODE = 257; // end of information\nconst MAX_BYTELENGTH = 12;\n\nfunction getByte(array, position, length) {\n  const d = position % 8;\n  const a = Math.floor(position / 8);\n  const de = 8 - d;\n  const ef = (position + length) - ((a + 1) * 8);\n  let fg = (8 * (a + 2)) - (position + length);\n  const dg = ((a + 2) * 8) - position;\n  fg = Math.max(0, fg);\n  if (a >= array.length) {\n    console.warn('ran off the end of the buffer before finding EOI_CODE (end on input code)');\n    return EOI_CODE;\n  }\n  let chunk1 = array[a] & ((2 ** (8 - d)) - 1);\n  chunk1 <<= (length - de);\n  let chunks = chunk1;\n  if (a + 1 < array.length) {\n    let chunk2 = array[a + 1] >>> fg;\n    chunk2 <<= Math.max(0, (length - dg));\n    chunks += chunk2;\n  }\n  if (ef > 8 && a + 2 < array.length) {\n    const hi = ((a + 3) * 8) - (position + length);\n    const chunk3 = array[a + 2] >>> hi;\n    chunks += chunk3;\n  }\n  return chunks;\n}\n\nfunction appendReversed(dest, source) {\n  for (let i = source.length - 1; i >= 0; i--) {\n    dest.push(source[i]);\n  }\n  return dest;\n}\n\nfunction decompress(input) {\n  const dictionaryIndex = new Uint16Array(4093);\n  const dictionaryChar = new Uint8Array(4093);\n  for (let i = 0; i <= 257; i++) {\n    dictionaryIndex[i] = 4096;\n    dictionaryChar[i] = i;\n  }\n  let dictionaryLength = 258;\n  let byteLength = MIN_BITS;\n  let position = 0;\n\n  function initDictionary() {\n    dictionaryLength = 258;\n    byteLength = MIN_BITS;\n  }\n  function getNext(array) {\n    const byte = getByte(array, position, byteLength);\n    position += byteLength;\n    return byte;\n  }\n  function addToDictionary(i, c) {\n    dictionaryChar[dictionaryLength] = c;\n    dictionaryIndex[dictionaryLength] = i;\n    dictionaryLength++;\n    return dictionaryLength - 1;\n  }\n  function getDictionaryReversed(n) {\n    const rev = [];\n    for (let i = n; i !== 4096; i = dictionaryIndex[i]) {\n      rev.push(dictionaryChar[i]);\n    }\n    return rev;\n  }\n\n  const result = [];\n  initDictionary();\n  const array = new Uint8Array(input);\n  let code = getNext(array);\n  let oldCode;\n  while (code !== EOI_CODE) {\n    if (code === CLEAR_CODE) {\n      initDictionary();\n      code = getNext(array);\n      while (code === CLEAR_CODE) {\n        code = getNext(array);\n      }\n\n      if (code === EOI_CODE) {\n        break;\n      } else if (code > CLEAR_CODE) {\n        throw new Error(`corrupted code at scanline ${code}`);\n      } else {\n        const val = getDictionaryReversed(code);\n        appendReversed(result, val);\n        oldCode = code;\n      }\n    } else if (code < dictionaryLength) {\n      const val = getDictionaryReversed(code);\n      appendReversed(result, val);\n      addToDictionary(oldCode, val[val.length - 1]);\n      oldCode = code;\n    } else {\n      const oldVal = getDictionaryReversed(oldCode);\n      if (!oldVal) {\n        throw new Error(`Bogus entry. Not in dictionary, ${oldCode} / ${dictionaryLength}, position: ${position}`);\n      }\n      appendReversed(result, oldVal);\n      result.push(oldVal[oldVal.length - 1]);\n      addToDictionary(oldCode, oldVal[oldVal.length - 1]);\n      oldCode = code;\n    }\n\n    if (dictionaryLength + 1 >= (2 ** byteLength)) {\n      if (byteLength === MAX_BYTELENGTH) {\n        oldCode = undefined;\n      } else {\n        byteLength++;\n      }\n    }\n    code = getNext(array);\n  }\n  return new Uint8Array(result);\n}\n\nexport default class LZWDecoder extends BaseDecoder {\n  decodeBlock(buffer) {\n    return decompress(buffer, false).buffer;\n  }\n}\n","function decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nexport function applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n"],"names":["applyPredictor","BaseDecoder","decode","fileDirectory","buffer","decoded","decodeBlock","predictor","Predictor","isTiled","StripOffsets","tileWidth","TileWidth","ImageWidth","tileHeight","TileLength","RowsPerStrip","ImageLength","BitsPerSample","PlanarConfiguration","MIN_BITS","CLEAR_CODE","EOI_CODE","MAX_BYTELENGTH","getByte","array","position","length","d","a","Math","floor","de","ef","fg","dg","max","console","warn","chunk1","chunks","chunk2","hi","chunk3","appendReversed","dest","source","i","push","decompress","input","dictionaryIndex","Uint16Array","dictionaryChar","Uint8Array","dictionaryLength","byteLength","initDictionary","getNext","byte","addToDictionary","c","getDictionaryReversed","n","rev","result","code","oldCode","Error","val","oldVal","undefined","LZWDecoder","decodeRowAcc","row","stride","offset","decodeRowFloatingPoint","bytesPerSample","index","count","wc","copy","slice","b","block","width","height","bitsPerSample","planarConfiguration","Uint32Array"],"sourceRoot":""}