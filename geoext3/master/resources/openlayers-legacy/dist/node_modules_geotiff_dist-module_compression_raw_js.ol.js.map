{"version":3,"file":"node_modules_geotiff_dist-module_compression_raw_js.ol.js","mappings":"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","sources":["webpack://ol/./node_modules/geotiff/dist-module/compression/basedecoder.js","webpack://ol/./node_modules/geotiff/dist-module/compression/raw.js","webpack://ol/./node_modules/geotiff/dist-module/predictor.js"],"sourcesContent":["import { applyPredictor } from '../predictor.js';\n\nexport default class BaseDecoder {\n  async decode(fileDirectory, buffer) {\n    const decoded = await this.decodeBlock(buffer);\n    const predictor = fileDirectory.Predictor || 1;\n    if (predictor !== 1) {\n      const isTiled = !fileDirectory.StripOffsets;\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\n      );\n      return applyPredictor(\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\n        fileDirectory.PlanarConfiguration,\n      );\n    }\n    return decoded;\n  }\n}\n","import BaseDecoder from './basedecoder.js';\n\nexport default class RawDecoder extends BaseDecoder {\n  decodeBlock(buffer) {\n    return buffer;\n  }\n}\n","function decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nexport function applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n"],"names":["applyPredictor","BaseDecoder","decode","fileDirectory","buffer","decoded","decodeBlock","predictor","Predictor","isTiled","StripOffsets","tileWidth","TileWidth","ImageWidth","tileHeight","TileLength","RowsPerStrip","ImageLength","BitsPerSample","PlanarConfiguration","RawDecoder","decodeRowAcc","row","stride","length","offset","i","decodeRowFloatingPoint","bytesPerSample","index","count","wc","copy","slice","b","block","width","height","bitsPerSample","planarConfiguration","Error","byteLength","Uint8Array","Uint16Array","Uint32Array"],"sourceRoot":""}